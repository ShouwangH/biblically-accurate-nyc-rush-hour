/**
 * Data Loading Infrastructure
 *
 * Provides centralized data loading for all simulation data files.
 * Components access data via useData() hook, never via direct fetch().
 *
 * Pattern per CLAUDE.md ยง8.4:
 * - DataProvider loads ALL JSON files at once
 * - Renders children only when data is ready
 * - Provides data via context
 */
import {
  createContext,
  useContext,
  useState,
  useEffect,
  ReactNode,
} from 'react';
import type {
  SimulationData,
  StationsFile,
  SubwayLinesFile,
  TrainSchedulesFile,
  RoadSegmentsFile,
  TripsFile,
  RoadbedsFile,
} from '../data/types';

// =============================================================================
// Feature Flags
// =============================================================================

/**
 * Feature flag to enable the trip-based train engine.
 * When true, loads trips.json and Trains.tsx uses TripEngine.
 * When false, uses the legacy segment-based TrainEngine.
 */
export const USE_TRIP_ENGINE = true;

/**
 * Asset source selection for 3D models.
 * - 'legacy': Original 2014 buildings.glb (5.7MB, ~300k tris)
 * - 'nyc3d': NYC DCP 3D Model 2018 export (larger, more detailed)
 *
 * Toggle this to roll back if performance tanks.
 */
export type AssetSource = 'legacy' | 'nyc3d';
export const ASSET_SOURCE: AssetSource = 'nyc3d';

/**
 * Asset paths based on source selection.
 */
export const ASSET_URLS = {
  legacy: {
    buildings: '/assets/buildings.glb',
    roadbed: null,  // No roadbed in legacy
    parks: null,
    water: null,
    landmarks: null,
  },
  nyc3d: {
    buildings: '/assets/nyc3d/buildings.glb',
    roadbed: '/assets/nyc3d/roadbed.glb',
    parks: '/assets/nyc3d/parks.glb',
    water: '/assets/nyc3d/water.glb',
    landmarks: '/assets/nyc3d/landmarks.glb',
  },
} as const;

/**
 * Get current asset URLs based on ASSET_SOURCE flag.
 */
export function getAssetUrls() {
  return ASSET_URLS[ASSET_SOURCE];
}

// =============================================================================
// Error Type
// =============================================================================

/**
 * Custom error class for data loading failures.
 * Includes the file that failed to load for better debugging.
 */
export class DataError extends Error {
  constructor(
    message: string,
    public readonly file: string
  ) {
    super(message);
    this.name = 'DataError';
  }
}

// =============================================================================
// Context Types
// =============================================================================

interface DataContextValue {
  /** Loaded simulation data, null while loading or on error */
  data: SimulationData | null;
  /** True while data is being fetched */
  isLoading: boolean;
  /** Error if loading failed, null otherwise */
  error: DataError | null;
}

// =============================================================================
// Context
// =============================================================================

const DataContext = createContext<DataContextValue | null>(null);

// =============================================================================
// Asset Paths
// =============================================================================

// In Vite, assets in public/ are served at root
// Real data files generated by scripts/fetch-*.py
const ASSET_PATHS = {
  stations: '/assets/stations.json',
  subwayLines: '/assets/subway_lines.json',
  trainSchedules: '/assets/train_schedules.json',
  roadSegments: '/assets/road_segments.json',
  trips: '/assets/trips.json',
  roadbeds: '/assets/roadbeds.json',
} as const;

// =============================================================================
// Fetch Helpers
// =============================================================================

/**
 * Fetches and parses a JSON file, throwing DataError on failure.
 */
async function fetchJson<T>(path: string, fileName: string): Promise<T> {
  const response = await fetch(path);

  if (!response.ok) {
    throw new DataError(
      `Failed to fetch ${fileName}: ${response.status} ${response.statusText}`,
      fileName
    );
  }

  return response.json() as Promise<T>;
}

/**
 * Loads all simulation data files in parallel.
 * Conditionally loads trips.json when USE_TRIP_ENGINE is enabled.
 */
async function loadAllData(): Promise<SimulationData> {
  // Base data that's always loaded
  const basePromises = [
    fetchJson<StationsFile>(ASSET_PATHS.stations, 'stations.json'),
    fetchJson<SubwayLinesFile>(ASSET_PATHS.subwayLines, 'subway_lines.json'),
    fetchJson<TrainSchedulesFile>(
      ASSET_PATHS.trainSchedules,
      'train_schedules.json'
    ),
    fetchJson<RoadSegmentsFile>(
      ASSET_PATHS.roadSegments,
      'road_segments.json'
    ),
  ] as const;

  // Conditionally load trips.json for trip-based engine
  const tripsPromise = USE_TRIP_ENGINE
    ? fetchJson<TripsFile>(ASSET_PATHS.trips, 'trips.json')
    : Promise.resolve(undefined);

  // Load roadbeds (optional - don't fail if missing)
  const roadbedsPromise = fetchJson<RoadbedsFile>(
    ASSET_PATHS.roadbeds,
    'roadbeds.json'
  ).catch(() => undefined);

  const [stations, subwayLines, trainSchedules, roadSegments, trips, roadbeds] =
    await Promise.all([...basePromises, tripsPromise, roadbedsPromise]);

  return {
    stations,
    subwayLines,
    trainSchedules,
    roadSegments,
    trips,
    roadbeds,
  };
}

// =============================================================================
// Provider Component
// =============================================================================

interface DataProviderProps {
  children: ReactNode;
}

/**
 * DataProvider loads all simulation data and provides it via context.
 *
 * Usage:
 * ```tsx
 * <DataProvider>
 *   <App />
 * </DataProvider>
 * ```
 */
export function DataProvider({ children }: DataProviderProps) {
  const [data, setData] = useState<SimulationData | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<DataError | null>(null);

  useEffect(() => {
    let cancelled = false;

    async function load() {
      try {
        const loadedData = await loadAllData();

        if (!cancelled) {
          setData(loadedData);
          setIsLoading(false);
        }
      } catch (err) {
        if (!cancelled) {
          if (err instanceof DataError) {
            setError(err);
          } else if (err instanceof Error) {
            setError(new DataError(err.message, 'unknown'));
          } else {
            setError(new DataError('Unknown error loading data', 'unknown'));
          }
          setIsLoading(false);
        }
      }
    }

    void load();

    return () => {
      cancelled = true;
    };
  }, []);

  const value: DataContextValue = {
    data,
    isLoading,
    error,
  };

  return <DataContext.Provider value={value}>{children}</DataContext.Provider>;
}

// =============================================================================
// Hook
// =============================================================================

/**
 * Hook to access simulation data from the DataProvider context.
 *
 * Must be used within a DataProvider.
 *
 * @returns Object with data, isLoading, and error properties
 * @throws Error if used outside of DataProvider
 *
 * Usage:
 * ```tsx
 * function MyComponent() {
 *   const { data, isLoading, error } = useData();
 *
 *   if (isLoading) return <LoadingScreen />;
 *   if (error) return <ErrorScreen error={error} />;
 *
 *   return <div>{data.stations.stations.length} stations loaded</div>;
 * }
 * ```
 */
export function useData(): DataContextValue {
  const context = useContext(DataContext);

  if (context === null) {
    throw new Error('useData must be used within a DataProvider');
  }

  return context;
}
